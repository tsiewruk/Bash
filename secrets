import os
import re
from pathlib import Path
import argparse
from typing import List, Dict, Set
import json
from datetime import datetime

class SecretScanner:
    def __init__(self):
        # Definicje wzorców dla różnych typów sekretów
        self.patterns = {
            'aws_access_key': r'AKIA[0-9A-Z]{16}',
            'aws_secret_key': r'[0-9a-zA-Z/+]{40}',
            'github_token': r'gh[pousr]_[0-9a-zA-Z]{36}',
            'generic_api_key': r'[aA][pP][iI][-_]?[kK][eE][yY].*[=:]\s*[\'"]*[0-9a-zA-Z]{32,45}[\'"]*',
            'private_key': r'-----BEGIN\s+PRIVATE\s+KEY-----',
            'password_in_code': r'(?i)(password|passwd|pwd)\s*[=:]\s*[\'"]((?!\{\{)[^\'"])+[\'"]',
            'connection_string': r'(?i)(mongodb|postgresql|mysql)://[^\s<>"\']+',
            'google_oauth': r'[0-9]+-[0-9A-Za-z_]{32}\.apps\.googleusercontent\.com',
            'jwt_token': r'eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*',
        }
        
        # Lista rozszerzeń plików do pominięcia
        self.exclude_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', 
                                 '.mp3', '.mp4', '.avi', '.mov', '.pdf', '.zip', 
                                 '.tar', '.gz', '.7z', '.pyc', '.class', '.o', '.so'}
        
        # Lista katalogów do pominięcia
        self.exclude_dirs = {'.git', 'node_modules', 'venv', '.env', '__pycache__', 
                           'build', 'dist', '.idea', '.vscode'}

    def is_binary(self, file_path: str) -> bool:
        """Sprawdza czy plik jest binarny."""
        try:
            with open(file_path, 'tr') as check_file:
                check_file.read(1024)
                return False
        except UnicodeDecodeError:
            return True

    def should_skip_file(self, file_path: str) -> bool:
        """Sprawdza czy plik powinien być pominięty."""
        file_extension = os.path.splitext(file_path)[1].lower()
        if file_extension in self.exclude_extensions:
            return True
        
        path_parts = Path(file_path).parts
        return any(part in self.exclude_dirs for part in path_parts)

    def scan_file(self, file_path: str) -> Dict[str, List[str]]:
        """Skanuje pojedynczy plik w poszukiwaniu sekretów."""
        if self.should_skip_file(file_path) or self.is_binary(file_path):
            return {}

        findings = {}
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            for secret_type, pattern in self.patterns.items():
                matches = re.finditer(pattern, content)
                for match in matches:
                    line_number = content.count('\n', 0, match.start()) + 1
                    if secret_type not in findings:
                        findings[secret_type] = []
                    findings[secret_type].append(f"Linia {line_number}: {match.group()}")
        except Exception as e:
            print(f"Błąd podczas skanowania pliku {file_path}: {str(e)}")
            
        return findings

    def scan_directory(self, directory: str) -> Dict[str, Dict[str, List[str]]]:
        """Skanuje całe repozytorium rekurencyjnie."""
        all_findings = {}
        
        for root, dirs, files in os.walk(directory):
            # Pomijamy wykluczone katalogi
            dirs[:] = [d for d in dirs if d not in self.exclude_dirs]
            
            for file in files:
                file_path = os.path.join(root, file)
                findings = self.scan_file(file_path)
                
                if findings:
                    relative_path = os.path.relpath(file_path, directory)
                    all_findings[relative_path] = findings
                    
        return all_findings

    def generate_report(self, findings: Dict[str, Dict[str, List[str]]], output_file: str):
        """Generuje raport w formacie JSON."""
        report = {
            'scan_date': datetime.now().isoformat(),
            'total_files_with_secrets': len(findings),
            'findings': findings
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        # Wyświetl podsumowanie w konsoli
        print(f"\nZnaleziono sekrety w {len(findings)} plikach.")
        for file_path, file_findings in findings.items():
            print(f"\nPlik: {file_path}")
            for secret_type, matches in file_findings.items():
                print(f"  {secret_type}: {len(matches)} znalezionych")

def main():
    parser = argparse.ArgumentParser(description='Skaner sekretów w repozytorium')
    parser.add_argument('path', help='Ścieżka do przeskanowania')
    parser.add_argument('--output', '-o', default='secret_scan_report.json',
                       help='Ścieżka do pliku wyjściowego (domyślnie: secret_scan_report.json)')
    
    args = parser.parse_args()
    
    scanner = SecretScanner()
    print(f"Rozpoczynam skanowanie: {args.path}")
    
    findings = scanner.scan_directory(args.path)
    scanner.generate_report(findings, args.output)
    
    print(f"\nRaport został zapisany do: {args.output}")

if __name__ == '__main__':
    main()
